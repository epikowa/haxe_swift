import haxe.Constraints;

class Reflect {
    @:throws
    public static function callMethod(o:Dynamic, func:Function, args:Array<Dynamic>):Dynamic {
        throw '#swift : not implemented';
    }

    @:throws
    public static function compare<T>(a:T, b:T):Int {
        throw '#swift : not implemented';
    }

    @:throws
    public static function compareMethods(f1:Dynamic, f2:Dynamic):Bool {
        throw '#swift : not implemented';
    }

    @:throws
    public static function copy<T>(o:Null<T>):Null<T> {
        throw '#swift : not implemented';
    }

    @:throws
    public static function deleteField(o:Dynamic, field:String):Bool {
        throw '#swift : not implemented';
    }

    @:throws
    public static function field(o:Dynamic, field:String):Dynamic {
        throw '#swift : not implemented';
    }

    @:throws
    public static function fields(o:Dynamic):Array<String> {
        throw '#swift : not implemented';
    }

    @:throws
    public static function getProperty(o:Dynamic, field:String):Dynamic {
        throw '#swift : not implemented';
    }

    @:throws
    public static function hasField(o:Dynamic, field:String):Bool {
        throw '#swift : not implemented';
    }

    @:throws
    public static function isEnumValue(v:Dynamic):Bool {
        throw '#swift : not implemented';
    }

    @:throws
    public static function isFunction(f:Dynamic):Bool {
        throw '#swift : not implemented';
    }

    @:throws
    public static function isObject(v:Dynamic):Bool {
        throw '#swift : not implemented';
    }

    @:throws
    public static function makeVarArgs(f:Array<Dynamic> -> Dynamic):Dynamic {
        throw '#swift : not implemented';
    }

    @:throws
    public static function setField(o:Dynamic, field:String, value:Dynamic):Void {
        throw '#swift : not implemented';
    }

    @:throws
    public static function setProperty(o:Dynamic, field:String, value:Dynamic):Void {
        throw '#swift : not implemented';
    }
}